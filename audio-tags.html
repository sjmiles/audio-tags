<link rel="import" href="../polymer/polymer.html">

<script src="src/libs/AudioContextMonkeyPatch.js"></script>

<polymer-element name="audio-context">
  <script>
    Polymer('audio-context', {
      ready: function() {
        this.context = new AudioContext();
        this.async('init');
      },
      init: function() {
        console.log('inserted audio context, now going through child nodes and seeing what we do with them');
        var context = this.context;
        Array.prototype.slice.call(this.children, 0).forEach(function(child) {
          if (child.init) {
            child.init(context);
            child.output.connect(context.destination);
          } else {
            console.log('no child init', child);
          }
        });
      }
    });
  </script>
</polymer-element>

<polymer-element name="audio-tag" class="audio">
  <script>
    Polymer('audio-tag', {
      init: function(audioContext) {
        // input: splitter?
        this.input = audioContext.createGain();
        // output: gain
        this.output = audioContext.createGain();
      },
      start: function(when) {
        console.log('prototype start', when);
      },
      stop: function(when) {
        console.log('prototype stop', when);
      },
      // Inspired by the visitor pattern... if classes overload initChild, that
      // implementation will be executed instead of the normal behaviour
      // (connecting each child output to our output) - see initChild
      // This allows us to have different initialisations depending on the type of
      // container node
      initChildren: function(audioContext) {
        Array.prototype.slice.call(this.children, 0).forEach(function(child, index) {
          this.initChild(audioContext, child, index);
        }, this);
      },
      initChild: function(audioContext, child, index) {
        if (child.init) {
          child.init(audioContext);
          child.output.connect(this.output);
        } else {
          console.log('no child init', child);
        }
      },
      initAttributes: function(which) {
        which.forEach(function(attr) {
          var value = this.getAttribute(attr);
          if(value !== null) {
            self[attr] = value;
          }
        }, this);
      }
    });
  </script>
</polymer-element>

<script src="src/js/audioComponents/OscillatorVoice.js"></script>
<script src="node_modules/midiutils/src/MIDIUtils.js"></script>

<polymer-element name="audio-oscillator" extends="audio-tag" attributes="frequency type playing">
  <template>
    OSCILLATOR<br />
    <label><input type="checkbox" checked="{{playing}}"> Playing</label><br>
    <label><select class="type" value="{{type}}">
      <option>sine</option>
      <option>square</option>
      <option>sawtooth</option>
      <option>triangle</option>
    </select> type</label><br />
    <label><input type="number" min="0" max="24000" value="{{frequency}}"> Hz</label><br />
    <label class="frequency"><input type="range" min="1" max="12000" step="0.5" value="{{frequency}}"><span></span> Hz</label><br />
    <label class="note"><span></span></label>
  </template>
  <script>
    Polymer('audio-oscillator', {
      playing: false,
      frequency: 220,
      type: 'sine',
      oscillator: {},
      init: function(audioContext) {
        this.super(arguments);
        this.oscillator = new OscillatorVoice(audioContext);
        this.oscillator.output.connect(this.output);
        this.typeChanged();
        this.frequencyChanged();
        this.playingChanged();
      },
      frequencyChanged: function() {
        this.oscillator.frequency = this.frequency;
      },
      typeChanged: function() {
        this.oscillator.type = this.type;
      },
      playingChanged: function() {
        if (this.oscillator) {
          this[this.playing ? 'start' : 'stop'](0);
        }
      },
      start: function(when) {
        this.oscillator.start(when);
      },
      stop: function(when) {
        this.oscillator.stop(when);
      }
    });
  </script>
</polymer-element>